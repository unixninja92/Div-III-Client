// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: ./pond.proto
package systems.obscure.servertestingwithouttor.protos;

import com.squareup.wire.Message;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import java.util.Collections;
import java.util.List;

import static com.squareup.wire.Message.Datatype.ENUM;
import static com.squareup.wire.Message.Label.REPEATED;

/**
 * Reply is the server's reply to the client.
 */
public final class Reply extends Message {

  public static final Status DEFAULT_STATUS = Status.OK;
  public static final List<SignedRevocation> DEFAULT_EXTRA_REVOCATIONS = Collections.emptyList();

  @ProtoField(tag = 1, type = ENUM)
  public final Status status;

  @ProtoField(tag = 2)
  public final AccountCreated account_created;

  @ProtoField(tag = 3)
  public final Fetched fetched;

  @ProtoField(tag = 4)
  public final ServerAnnounce announce;

  @ProtoField(tag = 5)
  public final UploadReply upload;

  @ProtoField(tag = 6)
  public final DownloadReply download;

  @ProtoField(tag = 7)
  public final SignedRevocation revocation;

  @ProtoField(tag = 8, label = REPEATED)
  public final List<SignedRevocation> extra_revocations;

  public Reply(Status status, AccountCreated account_created, Fetched fetched, ServerAnnounce announce, UploadReply upload, DownloadReply download, SignedRevocation revocation, List<SignedRevocation> extra_revocations) {
    this.status = status;
    this.account_created = account_created;
    this.fetched = fetched;
    this.announce = announce;
    this.upload = upload;
    this.download = download;
    this.revocation = revocation;
    this.extra_revocations = immutableCopyOf(extra_revocations);
  }

  private Reply(Builder builder) {
    this(builder.status, builder.account_created, builder.fetched, builder.announce, builder.upload, builder.download, builder.revocation, builder.extra_revocations);
    setBuilder(builder);
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof Reply)) return false;
    Reply o = (Reply) other;
    return equals(status, o.status)
        && equals(account_created, o.account_created)
        && equals(fetched, o.fetched)
        && equals(announce, o.announce)
        && equals(upload, o.upload)
        && equals(download, o.download)
        && equals(revocation, o.revocation)
        && equals(extra_revocations, o.extra_revocations);
  }

  @Override
  public int hashCode() {
    int result = hashCode;
    if (result == 0) {
      result = status != null ? status.hashCode() : 0;
      result = result * 37 + (account_created != null ? account_created.hashCode() : 0);
      result = result * 37 + (fetched != null ? fetched.hashCode() : 0);
      result = result * 37 + (announce != null ? announce.hashCode() : 0);
      result = result * 37 + (upload != null ? upload.hashCode() : 0);
      result = result * 37 + (download != null ? download.hashCode() : 0);
      result = result * 37 + (revocation != null ? revocation.hashCode() : 0);
      result = result * 37 + (extra_revocations != null ? extra_revocations.hashCode() : 1);
      hashCode = result;
    }
    return result;
  }

  public static final class Builder extends Message.Builder<Reply> {

    public Status status;
    public AccountCreated account_created;
    public Fetched fetched;
    public ServerAnnounce announce;
    public UploadReply upload;
    public DownloadReply download;
    public SignedRevocation revocation;
    public List<SignedRevocation> extra_revocations;

    public Builder() {
    }

    public Builder(Reply message) {
      super(message);
      if (message == null) return;
      this.status = message.status;
      this.account_created = message.account_created;
      this.fetched = message.fetched;
      this.announce = message.announce;
      this.upload = message.upload;
      this.download = message.download;
      this.revocation = message.revocation;
      this.extra_revocations = copyOf(message.extra_revocations);
    }

    public Builder status(Status status) {
      this.status = status;
      return this;
    }

    public Builder account_created(AccountCreated account_created) {
      this.account_created = account_created;
      return this;
    }

    public Builder fetched(Fetched fetched) {
      this.fetched = fetched;
      return this;
    }

    public Builder announce(ServerAnnounce announce) {
      this.announce = announce;
      return this;
    }

    public Builder upload(UploadReply upload) {
      this.upload = upload;
      return this;
    }

    public Builder download(DownloadReply download) {
      this.download = download;
      return this;
    }

    public Builder revocation(SignedRevocation revocation) {
      this.revocation = revocation;
      return this;
    }

    public Builder extra_revocations(List<SignedRevocation> extra_revocations) {
      this.extra_revocations = checkForNulls(extra_revocations);
      return this;
    }

    @Override
    public Reply build() {
      return new Reply(this);
    }
  }

  public enum Status
      implements ProtoEnum {
    OK(0),
    PARSE_ERROR(1),
    NO_REQUEST(2),
    INTERNAL_ERROR(3),
    IDENTITY_ALREADY_KNOWN(10),
    OVERLOAD(11),
    NO_SUCH_ADDRESS(12),
    DELIVERY_SIGNATURE_INVALID(13),
    INCORRECT_GENERATION(14),
    MAILBOX_FULL(15),
    NO_ACCOUNT(16),
    OVER_QUOTA(17),
    FILE_LARGER_THAN_SIZE(18),
    FILE_COMPLETE(19),
    NO_SUCH_FILE(20),
    RESUME_PAST_END_OF_FILE(21),
    GENERATION_REVOKED(22),
    CANNOT_PARSE_REVOCATION(23),
    /**
     * REGISTRATION_DISABLED may be returned after a NewAccount
     * request to indicate the the server doesn't accept new
     * registrations.
     */
    REGISTRATION_DISABLED(24),
    /**
     * HMAC_KEY_ALREADY_SET is returned in reply to a HMACSetup
     * request if a different HMAC key has already been setup.
     */
    HMAC_KEY_ALREADY_SET(25),
    /**
     * HMAC_NOT_SETUP results from a delivery attempt when the
     * recipient hasn't configured an HMAC key.
     */
    HMAC_NOT_SETUP(26),
    /**
     * HMAC_INCORRECT results from a delivery when the HMAC of the
     * one-time public key doesn't validate.
     */
    HMAC_INCORRECT(27),
    /**
     * HMAC_USED results from a delivery when the HMAC value has
     * already been used.
     */
    HMAC_USED(28),
    /**
     * HMAC_REVOKED results from a delivery when the HMAC value has
     * been marked as revoked.
     */
    HMAC_REVOKED(29);

    private final int value;

    private Status(int value) {
      this.value = value;
    }

    @Override
    public int getValue() {
      return value;
    }
  }
}
