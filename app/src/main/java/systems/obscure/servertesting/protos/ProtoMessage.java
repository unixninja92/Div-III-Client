// Code generated by Wire protocol buffer compiler, do not edit.
// Source file: ./pond.proto
package systems.obscure.servertesting.protos;

import com.squareup.wire.Message;
import com.squareup.wire.ProtoEnum;
import com.squareup.wire.ProtoField;
import java.util.Collections;
import java.util.List;
import okio.ByteString;

import static com.squareup.wire.Message.Datatype.BYTES;
import static com.squareup.wire.Message.Datatype.ENUM;
import static com.squareup.wire.Message.Datatype.FIXED64;
import static com.squareup.wire.Message.Datatype.INT32;
import static com.squareup.wire.Message.Datatype.INT64;
import static com.squareup.wire.Message.Datatype.STRING;
import static com.squareup.wire.Message.Datatype.UINT32;
import static com.squareup.wire.Message.Datatype.UINT64;
import static com.squareup.wire.Message.Label.REPEATED;
import static com.squareup.wire.Message.Label.REQUIRED;

/**
 * ProtoMessage is typically contained within a NaCl box that's passed between
 * clients using Delivery and Fetch.
 */
public final class ProtoMessage extends Message {

  public static final Long DEFAULT_ID = 0L;
  public static final Long DEFAULT_TIME = 0L;
  public static final ByteString DEFAULT_BODY = ByteString.EMPTY;
  public static final Encoding DEFAULT_BODY_ENCODING = Encoding.RAW;
  public static final ByteString DEFAULT_MY_NEXT_DH = ByteString.EMPTY;
  public static final Long DEFAULT_IN_REPLY_TO = 0L;
  public static final List<Long> DEFAULT_ALSO_ACK = Collections.emptyList();
  public static final List<Attachment> DEFAULT_FILES = Collections.emptyList();
  public static final List<Detachment> DEFAULT_DETACHED_FILES = Collections.emptyList();
  public static final Integer DEFAULT_SUPPORTED_VERSION = 0;

  /**
   * id is generated by the sender in order for the receiver to associate
   * replies.
   */
  @ProtoField(tag = 1, type = FIXED64, label = REQUIRED)
  public final Long id;

  /**
   * time is the creation time of the message in epoch nanoseconds.
   */
  @ProtoField(tag = 2, type = INT64, label = REQUIRED)
  public final Long time;

  /**
   * body, after decoding, is a utf8 message.
   */
  @ProtoField(tag = 3, type = BYTES, label = REQUIRED)
  public final ByteString body;

  @ProtoField(tag = 4, type = ENUM)
  public final Encoding body_encoding;

  /**
   * my_next_dh contains a Curve25519 public value for future messages.
   */
  @ProtoField(tag = 5, type = BYTES)
  public final ByteString my_next_dh;

  /**
   * in_reply_to, if set, contains the |id| value of a previous message
   * sent by the recipient.
   */
  @ProtoField(tag = 6, type = UINT64)
  public final Long in_reply_to;

  /**
   * also_ack contains message ids for other messages that are also
   * acknowledged by this message.
   */
  @ProtoField(tag = 10, type = UINT64, label = REPEATED)
  public final List<Long> also_ack;

  @ProtoField(tag = 7, label = REPEATED)
  public final List<Attachment> files;

  @ProtoField(tag = 8, label = REPEATED)
  public final List<Detachment> detached_files;

  /**
   * supported_version allows a client to advertise the maximum supported
   * version that it speaks.
   */
  @ProtoField(tag = 9, type = INT32)
  public final Integer supported_version;

  public ProtoMessage(Long id, Long time, ByteString body, Encoding body_encoding, ByteString my_next_dh, Long in_reply_to, List<Long> also_ack, List<Attachment> files, List<Detachment> detached_files, Integer supported_version) {
    this.id = id;
    this.time = time;
    this.body = body;
    this.body_encoding = body_encoding;
    this.my_next_dh = my_next_dh;
    this.in_reply_to = in_reply_to;
    this.also_ack = immutableCopyOf(also_ack);
    this.files = immutableCopyOf(files);
    this.detached_files = immutableCopyOf(detached_files);
    this.supported_version = supported_version;
  }

  private ProtoMessage(Builder builder) {
    this(builder.id, builder.time, builder.body, builder.body_encoding, builder.my_next_dh, builder.in_reply_to, builder.also_ack, builder.files, builder.detached_files, builder.supported_version);
    setBuilder(builder);
  }

  @Override
  public boolean equals(Object other) {
    if (other == this) return true;
    if (!(other instanceof ProtoMessage)) return false;
    ProtoMessage o = (ProtoMessage) other;
    return equals(id, o.id)
        && equals(time, o.time)
        && equals(body, o.body)
        && equals(body_encoding, o.body_encoding)
        && equals(my_next_dh, o.my_next_dh)
        && equals(in_reply_to, o.in_reply_to)
        && equals(also_ack, o.also_ack)
        && equals(files, o.files)
        && equals(detached_files, o.detached_files)
        && equals(supported_version, o.supported_version);
  }

  @Override
  public int hashCode() {
    int result = hashCode;
    if (result == 0) {
      result = id != null ? id.hashCode() : 0;
      result = result * 37 + (time != null ? time.hashCode() : 0);
      result = result * 37 + (body != null ? body.hashCode() : 0);
      result = result * 37 + (body_encoding != null ? body_encoding.hashCode() : 0);
      result = result * 37 + (my_next_dh != null ? my_next_dh.hashCode() : 0);
      result = result * 37 + (in_reply_to != null ? in_reply_to.hashCode() : 0);
      result = result * 37 + (also_ack != null ? also_ack.hashCode() : 1);
      result = result * 37 + (files != null ? files.hashCode() : 1);
      result = result * 37 + (detached_files != null ? detached_files.hashCode() : 1);
      result = result * 37 + (supported_version != null ? supported_version.hashCode() : 0);
      hashCode = result;
    }
    return result;
  }

  public static final class Builder extends Message.Builder<ProtoMessage> {

    public Long id;
    public Long time;
    public ByteString body;
    public Encoding body_encoding;
    public ByteString my_next_dh;
    public Long in_reply_to;
    public List<Long> also_ack;
    public List<Attachment> files;
    public List<Detachment> detached_files;
    public Integer supported_version;

    public Builder() {
    }

    public Builder(ProtoMessage message) {
      super(message);
      if (message == null) return;
      this.id = message.id;
      this.time = message.time;
      this.body = message.body;
      this.body_encoding = message.body_encoding;
      this.my_next_dh = message.my_next_dh;
      this.in_reply_to = message.in_reply_to;
      this.also_ack = copyOf(message.also_ack);
      this.files = copyOf(message.files);
      this.detached_files = copyOf(message.detached_files);
      this.supported_version = message.supported_version;
    }

    /**
     * id is generated by the sender in order for the receiver to associate
     * replies.
     */
    public Builder id(Long id) {
      this.id = id;
      return this;
    }

    /**
     * time is the creation time of the message in epoch nanoseconds.
     */
    public Builder time(Long time) {
      this.time = time;
      return this;
    }

    /**
     * body, after decoding, is a utf8 message.
     */
    public Builder body(ByteString body) {
      this.body = body;
      return this;
    }

    public Builder body_encoding(Encoding body_encoding) {
      this.body_encoding = body_encoding;
      return this;
    }

    /**
     * my_next_dh contains a Curve25519 public value for future messages.
     */
    public Builder my_next_dh(ByteString my_next_dh) {
      this.my_next_dh = my_next_dh;
      return this;
    }

    /**
     * in_reply_to, if set, contains the |id| value of a previous message
     * sent by the recipient.
     */
    public Builder in_reply_to(Long in_reply_to) {
      this.in_reply_to = in_reply_to;
      return this;
    }

    /**
     * also_ack contains message ids for other messages that are also
     * acknowledged by this message.
     */
    public Builder also_ack(List<Long> also_ack) {
      this.also_ack = checkForNulls(also_ack);
      return this;
    }

    public Builder files(List<Attachment> files) {
      this.files = checkForNulls(files);
      return this;
    }

    public Builder detached_files(List<Detachment> detached_files) {
      this.detached_files = checkForNulls(detached_files);
      return this;
    }

    /**
     * supported_version allows a client to advertise the maximum supported
     * version that it speaks.
     */
    public Builder supported_version(Integer supported_version) {
      this.supported_version = supported_version;
      return this;
    }

    @Override
    public ProtoMessage build() {
      checkRequiredFields();
      return new ProtoMessage(this);
    }
  }

  public enum Encoding
      implements ProtoEnum {
    RAW(0),
    GZIP(1);

    private final int value;

    private Encoding(int value) {
      this.value = value;
    }

    @Override
    public int getValue() {
      return value;
    }
  }

  public static final class Attachment extends Message {

    public static final String DEFAULT_FILENAME = "";
    public static final ByteString DEFAULT_CONTENTS = ByteString.EMPTY;

    @ProtoField(tag = 1, type = STRING, label = REQUIRED)
    public final String filename;

    @ProtoField(tag = 2, type = BYTES, label = REQUIRED)
    public final ByteString contents;

    public Attachment(String filename, ByteString contents) {
      this.filename = filename;
      this.contents = contents;
    }

    private Attachment(Builder builder) {
      this(builder.filename, builder.contents);
      setBuilder(builder);
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof Attachment)) return false;
      Attachment o = (Attachment) other;
      return equals(filename, o.filename)
          && equals(contents, o.contents);
    }

    @Override
    public int hashCode() {
      int result = hashCode;
      if (result == 0) {
        result = filename != null ? filename.hashCode() : 0;
        result = result * 37 + (contents != null ? contents.hashCode() : 0);
        hashCode = result;
      }
      return result;
    }

    public static final class Builder extends Message.Builder<Attachment> {

      public String filename;
      public ByteString contents;

      public Builder() {
      }

      public Builder(Attachment message) {
        super(message);
        if (message == null) return;
        this.filename = message.filename;
        this.contents = message.contents;
      }

      public Builder filename(String filename) {
        this.filename = filename;
        return this;
      }

      public Builder contents(ByteString contents) {
        this.contents = contents;
        return this;
      }

      @Override
      public Attachment build() {
        checkRequiredFields();
        return new Attachment(this);
      }
    }
  }

  public static final class Detachment extends Message {

    public static final String DEFAULT_FILENAME = "";
    public static final Long DEFAULT_SIZE = 0L;
    public static final Long DEFAULT_PADDED_SIZE = 0L;
    public static final Integer DEFAULT_CHUNK_SIZE = 0;
    public static final ByteString DEFAULT_KEY = ByteString.EMPTY;
    public static final String DEFAULT_URL = "";

    @ProtoField(tag = 1, type = STRING, label = REQUIRED)
    public final String filename;

    @ProtoField(tag = 2, type = UINT64, label = REQUIRED)
    public final Long size;

    @ProtoField(tag = 3, type = UINT64, label = REQUIRED)
    public final Long padded_size;

    @ProtoField(tag = 4, type = UINT32, label = REQUIRED)
    public final Integer chunk_size;

    @ProtoField(tag = 5, type = BYTES, label = REQUIRED)
    public final ByteString key;

    @ProtoField(tag = 6, type = STRING)
    public final String url;

    public Detachment(String filename, Long size, Long padded_size, Integer chunk_size, ByteString key, String url) {
      this.filename = filename;
      this.size = size;
      this.padded_size = padded_size;
      this.chunk_size = chunk_size;
      this.key = key;
      this.url = url;
    }

    private Detachment(Builder builder) {
      this(builder.filename, builder.size, builder.padded_size, builder.chunk_size, builder.key, builder.url);
      setBuilder(builder);
    }

    @Override
    public boolean equals(Object other) {
      if (other == this) return true;
      if (!(other instanceof Detachment)) return false;
      Detachment o = (Detachment) other;
      return equals(filename, o.filename)
          && equals(size, o.size)
          && equals(padded_size, o.padded_size)
          && equals(chunk_size, o.chunk_size)
          && equals(key, o.key)
          && equals(url, o.url);
    }

    @Override
    public int hashCode() {
      int result = hashCode;
      if (result == 0) {
        result = filename != null ? filename.hashCode() : 0;
        result = result * 37 + (size != null ? size.hashCode() : 0);
        result = result * 37 + (padded_size != null ? padded_size.hashCode() : 0);
        result = result * 37 + (chunk_size != null ? chunk_size.hashCode() : 0);
        result = result * 37 + (key != null ? key.hashCode() : 0);
        result = result * 37 + (url != null ? url.hashCode() : 0);
        hashCode = result;
      }
      return result;
    }

    public static final class Builder extends Message.Builder<Detachment> {

      public String filename;
      public Long size;
      public Long padded_size;
      public Integer chunk_size;
      public ByteString key;
      public String url;

      public Builder() {
      }

      public Builder(Detachment message) {
        super(message);
        if (message == null) return;
        this.filename = message.filename;
        this.size = message.size;
        this.padded_size = message.padded_size;
        this.chunk_size = message.chunk_size;
        this.key = message.key;
        this.url = message.url;
      }

      public Builder filename(String filename) {
        this.filename = filename;
        return this;
      }

      public Builder size(Long size) {
        this.size = size;
        return this;
      }

      public Builder padded_size(Long padded_size) {
        this.padded_size = padded_size;
        return this;
      }

      public Builder chunk_size(Integer chunk_size) {
        this.chunk_size = chunk_size;
        return this;
      }

      public Builder key(ByteString key) {
        this.key = key;
        return this;
      }

      public Builder url(String url) {
        this.url = url;
        return this;
      }

      @Override
      public Detachment build() {
        checkRequiredFields();
        return new Detachment(this);
      }
    }
  }
}
